import { NextResponse } from "next/server";
import { writeFile, mkdir } from "fs/promises";
import path from "path";

export async function POST(request: Request) {
  try {
    const { videoId, title, transcript, quotes, published, quotesOnly } =
      await request.json();

    if (!videoId) {
      return NextResponse.json(
        { error: "Video ID is required" },
        { status: 400 }
      );
    }

    if (!quotesOnly && !transcript) {
      return NextResponse.json(
        { error: "Transcript is required" },
        { status: 400 }
      );
    }

    // Create exports directory if it doesn't exist
    const exportsDir = path.join(process.cwd(), "exports");
    try {
      await mkdir(exportsDir, { recursive: true });
    } catch (error) {
      // Directory might already exist, that's fine
    }

    // Format the markdown content optimized for LLM knowledge base ingestion
    const exportDate = new Date().toISOString();
    const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;
    const quotesCount = quotes?.length || 0;

    const markdown = quotesOnly
      ? `# ${title || "Video Quotes"}

## Metadata

**Video ID:** ${videoId}  
**Video URL:** ${videoUrl}  
**Published Date:** ${published || "Unknown"}  
**Export Date:** ${exportDate}  
**Source:** Charles Hoskinson (@charleshoskinsoncrypto)  
**Content Type:** Extracted Quotes  
**Number of Quotes:** ${quotesCount}

---

## Quotes

${
  quotes && quotes.length > 0
    ? quotes
        .map(
          (quote: string, index: number) => `### Quote ${index + 1}

${quote}`
        )
        .join("\n\n---\n\n")
    : "*No quotes extracted*"
}

---

*Generated by Hoskinson Harvester™ - Optimized for LLM Knowledge Base Ingestion*`
      : `# ${title || "Video Transcript"}

## Metadata

**Video ID:** ${videoId}  
**Video URL:** ${videoUrl}  
**Published Date:** ${published || "Unknown"}  
**Export Date:** ${exportDate}  
**Source:** Charles Hoskinson (@charleshoskinsoncrypto)  
**Content Type:** Full Transcript with Extracted Quotes  
**Transcript Length:** ${transcript.length} characters  
**Number of Quotes Extracted:** ${quotesCount}

---

## Full Transcript

${transcript}

---

## Extracted Quotes

${
  quotes && quotes.length > 0
    ? quotes
        .map(
          (quote: string, index: number) => `### Quote ${index + 1}

${quote}`
        )
        .join("\n\n---\n\n")
    : "*No quotes extracted*"
}

---

*Generated by Hoskinson Harvester™ - Optimized for LLM Knowledge Base Ingestion*`;

    // Create filename from video ID and title (sanitized)
    const sanitizedTitle = (title || "video")
      .replace(/[^a-z0-9]/gi, "_")
      .toLowerCase()
      .substring(0, 50);
    const suffix = quotesOnly ? "_quotes" : "";
    const filename = `${videoId}_${sanitizedTitle}${suffix}.md`;
    const filePath = path.join(exportsDir, filename);

    // Write the file
    await writeFile(filePath, markdown, "utf-8");

    return NextResponse.json({
      success: true,
      filename,
      path: filePath,
      message: `Exported to ${filename}`,
    });
  } catch (error: any) {
    console.error("Error exporting file:", error);
    return NextResponse.json(
      {
        error: "Failed to export file",
        details: error.message,
      },
      { status: 500 }
    );
  }
}
